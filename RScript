-- Valox Hub v1.8.7
-- כל הקרדיט ל-Valox Creations
local DISCORD_LINK = "."

-- ======= ניקוי הרצות קודמות =======
if getgenv().Rayfield and type(getgenv().Rayfield.Destroy) == "function" then
    pcall(function() getgenv().Rayfield:Destroy() end)
end
getgenv().Rayfield = nil

if getgenv().Connections then
    for _, c in pairs(getgenv().Connections) do
        pcall(function() c:Disconnect() end)
    end
end
getgenv().Connections = {}

if getgenv().ActiveCircles then
    for _, c in pairs(getgenv().ActiveCircles) do
        pcall(function() if c and c.Remove then c:Remove() end end)
    end
end
getgenv().ActiveCircles = {}

if getgenv().ESPBoxes then
    for _, b in pairs(getgenv().ESPBoxes) do
        pcall(function() if b and b.Destroy then b:Destroy() end end)
    end
end
getgenv().ESPBoxes = {}

if getgenv().ESPNames then
    for _, n in pairs(getgenv().ESPNames) do
        pcall(function() if n and n.Destroy then n:Destroy() end end)
    end
end
getgenv().ESPNames = {}

if getgenv().SkeletonLines then
    for plr, conn in pairs(getgenv().SkeletonLines) do
        pcall(function() if conn.Connection then conn.Connection:Disconnect() end end)
        for _, line in pairs(conn and conn.Limbs or {}) do
            pcall(function() if line and line.Remove then line:Remove() end end)
        end
    end
end
getgenv().SkeletonLines = {}

if getgenv().AntiFlingParts then
    for _, part in pairs(getgenv().AntiFlingParts) do
        pcall(function() if part and part.Destroy then part:Destroy() end end)
    end
end
getgenv().AntiFlingParts = {}

if getgenv().HitboxAdornments then
    for _, adorn in pairs(getgenv().HitboxAdornments) do
        pcall(function() if adorn and adorn.Destroy then adorn:Destroy() end end)
    end
end

loadstring(game:HttpGet("https://raw.githubusercontent.com/shamai707/RScript/refs/heads/main/RScript"))()

getgenv().HitboxAdornments = {}

for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
    if plr ~= game:GetService("Players").LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
        pcall(function()
            local root = plr.Character.HumanoidRootPart
            root.Size = Vector3.new(2, 2, 1)
            root.Transparency = 1
            root.CanCollide = true
            root.Material = Enum.Material.Plastic
            root.BrickColor = BrickColor.new("Medium stone grey")
        end)
    end
end

-- ======= הגדרות ברירת מחדל =======
getgenv().AimbotSettings = getgenv().AimbotSettings or {
    Enabled = false,
    SmartAimbot = true,
    Mode = "Hold",
    TeamCheck = false,
    Prediction = "Off",
    Smoothing = "Off",
    TargetPart = "Torso",
    LockTarget = false,
    LockedTarget = nil
}

getgenv().CircleSettings = getgenv().CircleSettings or {
    FOV = 120,
    Color = Color3.fromRGB(255, 255, 255),
    Rainbow = false,
    Thickness = 2,
    RainbowSpeed = 5,
    Visible = true
}

getgenv().ESPSettings = getgenv().ESPSettings or {
    Enabled = false,
    SkeletonEnabled = false,
    NamesEnabled = false,
    Color = Color3.fromRGB(255, 0, 0),
    SkeletonColor = Color3.fromRGB(0, 255, 0),
    MaxDistance = 500
}

getgenv().PlayerSettings = getgenv().PlayerSettings or {
    WalkspeedEnabled = false,
    Walkspeed = 16,
    JumpPowerEnabled = false,
    JumpPower = 50,
    InfiniteJump = false,
    NoclipEnabled = false,
    FlyEnabled = false,
    FlySpeed = 50
}

getgenv().MiscSettings = getgenv().MiscSettings or {
    AntiAFK = false,
    AntiFling = false,
    PlasticMaterialsEnabled = false,
    DisableNotifications = false
}

getgenv().HomeSettings = getgenv().HomeSettings or {
    HitboxEnabled = false,
    HitboxSize = 50
}

-- ======= שירותים (Services) =======
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local VirtualUser = game:GetService("VirtualUser")
local CoreGui = game:GetService("CoreGui")

-- טבלאות זמן ריצה
getgenv().ActiveCircles = getgenv().ActiveCircles or {}
getgenv().ESPBoxes = getgenv().ESPBoxes or {}
getgenv().ESPNames = getgenv().ESPNames or {}
getgenv().SkeletonLines = getgenv().SkeletonLines or {}
getgenv().AntiFlingParts = getgenv().AntiFlingParts or {}
getgenv().Connections = getgenv().Connections or {}
getgenv().HitboxAdornments = getgenv().HitboxAdornments or {}

local objectCache = {} -- אחסון מאפיינים מקוריים

-- ======= פונקציות עזר =======
local function DestroyAllCircles()
    for _, c in pairs(getgenv().ActiveCircles) do
        pcall(function() if c and c.Remove then c:Remove() end end)
    end
    getgenv().ActiveCircles = {}
end

local function ClearESPBoxes()
    for plr, box in pairs(getgenv().ESPBoxes) do
        pcall(function() if box and box.Destroy then box:Destroy() end end)
        getgenv().ESPBoxes[plr] = nil
    end
end

local function ClearESPNames()
    for plr, name in pairs(getgenv().ESPNames) do
        pcall(function() if name and name.Destroy then name:Destroy() end end)
        getgenv().ESPNames[plr] = nil
    end
end

local function ClearSkeletonLines()
    for plr, conn in pairs(getgenv().SkeletonLines) do
        pcall(function() 
            if conn.Connection then conn.Connection:Disconnect() end
            for _, line in pairs(conn.Limbs or {}) do
                pcall(function() if line and line.Remove then line:Remove() end end)
            end
        end)
        getgenv().SkeletonLines[plr] = nil
    end
end

local function ClearHitboxAdornments()
    for _, adorn in pairs(getgenv().HitboxAdornments) do
        pcall(function() if adorn and adorn.Destroy then adorn:Destroy() end end)
    end
    getgenv().HitboxAdornments = {}
end

local function UnloadAll()
    DestroyAllCircles()
    ClearESPBoxes()
    ClearESPNames()
    ClearSkeletonLines()
    ClearHitboxAdornments()
    for _, conn in pairs(getgenv().Connections) do
        pcall(function() conn:Disconnect() end)
    end
    getgenv().Connections = {}
    for _, part in pairs(getgenv().AntiFlingParts) do
        pcall(function() if part and part.Destroy then part:Destroy() end end)
    end
    getgenv().AntiFlingParts = {}
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            pcall(function()
                local root = plr.Character.HumanoidRootPart
                root.Size = Vector3.new(2, 2, 1)
                root.Transparency = 1
                root.CanCollide = true
                root.Material = Enum.Material.Plastic
                root.BrickColor = BrickColor.new("Medium stone grey")
            end)
        end
    end
    for obj, props in pairs(objectCache or {}) do
        pcall(function()
            if obj and obj.Parent and props.Material then
                obj.Material = props.Material
            end
        end)
    end
    objectCache = {}
    if getgenv().Rayfield and type(getgenv().Rayfield.Destroy) == "function" then
        pcall(function() getgenv().Rayfield:Destroy() end)
    end
    getgenv().Rayfield = nil
    getgenv().ScriptLoaded = false
end

local function getAimPartFromName(character, name)
    if not character then return nil end
    if name == "Head" then
        return character:FindFirstChild("Head")
    else
        return character:FindFirstChild("HumanoidRootPart")
            or character:FindFirstChild("UpperTorso")
            or character:FindFirstChild("Torso")
            or character:FindFirstChild("LowerTorso")
    end
end

-- ======= חומרי פלסטיק (Plastic Materials) =======
local function updateWorldObjects()
    if not getgenv().MiscSettings then
        warn("MiscSettings is nil in updateWorldObjects")
        return
    end
    local success, err = pcall(function()
        if getgenv().MiscSettings.PlasticMaterialsEnabled then
            local allObjects = game:GetService("Workspace"):GetDescendants()
            for _, object in ipairs(allObjects) do
                if object:IsA("BasePart") then
                    local success, objErr = pcall(function()
                        if not objectCache[object] then
                            objectCache[object] = { Material = object.Material }
                        end
                        object.Material = Enum.Material.Plastic
                    end)
                    if not success then
                        warn("Error updating object material: " .. tostring(objErr))
                    end
                end
            end
        else
            for obj, props in pairs(objectCache) do
                local success, objErr = pcall(function()
                    if obj and obj.Parent and props.Material then
                        obj.Material = props.Material
                    end
                end)
                if not success then
                    warn("Error reverting object material: " .. tostring(objErr))
                end
            end
        end
    end)
    if not success then
        warn("updateWorldObjects Error: " .. tostring(err))
        pcall(function()
            Rayfield:Notify({
                Title = "שגיאת Valox Hub",
                Content = "נכשל בעדכון חומרים: " .. tostring(err),
                Duration = 5
            })
        end)
    end
end

-- ======= טעינת Rayfield =======
local ok, Rayfield = pcall(function()
    return loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
end)
if not ok or not Rayfield then
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "שגיאת Valox Hub",
            Text = "טעינת ממשק ה-Rayfield נכשלה. בדוק את האקזקיוטור או הרשת שלך.",
            Duration = 5
        })
    end)
    return
end
getgenv().Rayfield = Rayfield

-- ======= בדיקת נייד =======
local isMobile = UserInputService.TouchEnabled or (UserInputService.KeyboardEnabled == false)

-- ======= יצירת ממשק משתמש =======
local Window
local success, err = pcall(function()
    Window = Rayfield:CreateWindow({
        Name = "Valox Hub",
        LoadingTitle = "טוען Valox Hub",
        LoadingSubtitle = "מאת Valox Creations",
        ConfigurationSaving = { Enabled = true, FolderName = "ValoxHub", FileName = "Settings" },
        KeySystem = false
    })
end)
if not success then
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "שגיאת Valox Hub",
            Text = "יצירת חלון ממשק המשתמש נכשלה: " .. tostring(err),
            Duration = 5
        })
    end)
    return
end

-- ======= יצירת כרטיסיות =======
local success, err = pcall(function()
    local HomeTab = Window:CreateTab("בית", "home")
    local AimbotTab, CircleTab, ESPTab, MiscTab, PlayerTab
    if not isMobile then
        AimbotTab = Window:CreateTab("איימבוט", "target")
        CircleTab = Window:CreateTab("מעגל", "circle")
    end
    ESPTab = Window:CreateTab("ESP", "eye")
    MiscTab = Window:CreateTab("שונות", "settings")
    PlayerTab = Window:CreateTab("שחקן", "user")

    -- ======= כרטיסיית בית: קישור לדיסקורד, מפעיל האבים ויומן שינויים =======
    HomeTab:CreateSection("קהילה")
    HomeTab:CreateButton({
        Name = "העתק קישור",
        Callback = function()
            local success, err = pcall(function()
                setclipboard(DISCORD_LINK)
                if not getgenv().MiscSettings.DisableNotifications then
                    Rayfield:Notify({
                        Title = "Valox Hub",
                        Content = "קישור הדיסקורד הועתק!",
                        Duration = 3
                    })
                end
            end)
            if not success then
                warn("Failed to copy Discord link: " .. tostring(err))
                if not getgenv().MiscSettings.DisableNotifications then
                    Rayfield:Notify({
                        Title = "שגיאת Valox Hub",
                        Content = "העתקת קישור הדיסקורד נכשלה: " .. tostring(err),
                        Duration = 5
                    })
                end
            end
        end
    })

    HomeTab:CreateSection("מפעיל האבים")
    local hubs = {
        ["H4x Scripts"] = "https://raw.githubusercontent.com/H4xScripts/Loader/refs/heads/main/loader.lua",
        ["VoidWare"] = "https://raw.githubusercontent.com/VapeVoidware/VWExtra/main/NightsInTheForest.lua",
        ["Infinite Yield"] = "https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source",
        ["Vertex"] = "https://raw.githubusercontent.com/vertex-peak/vertex/refs/heads/main/loadstring"
    }
    for name, url in pairs(hubs) do
        HomeTab:CreateButton({
            Name = "טען " .. name,
            Callback = function()
                if not url or url == "" then
                    if not getgenv().MiscSettings.DisableNotifications then
                        Rayfield:Notify({
                            Title = "Valox Hub",
                            Content = "לא הוגדר URL עבור " .. name,
                            Duration = 3
                        })
                    end
                    return
                end
                if not getgenv().MiscSettings.DisableNotifications then
                    Rayfield:Notify({
                        Title = "Valox Hub",
                        Content = "טוען " .. name,
                        Duration = 2
                    })
                end
                local ok, err = pcall(function()
                    local scriptText = game:HttpGet(url, true)
                    local fn = loadstring(scriptText)
                    if type(fn) == "function" then fn() end
                end)
                if not ok then
                    if not getgenv().MiscSettings.DisableNotifications then
                        Rayfield:Notify({
                            Title = "Valox Hub",
                            Content = "טעינת " .. name .. " נכשלה: " .. tostring(err),
                            Duration = 3
                        })
                    end
                else
                    if not getgenv().MiscSettings.DisableNotifications then
                        Rayfield:Notify({
                            Title = "Valox Hub",
                            Content = name .. " נטען",
                            Duration = 2
                        })
                    end
                end
            end
        })
    end

    HomeTab:CreateSection("יומן שינויים ועדכונים")
    HomeTab:CreateParagraph({
        Title = "יומן שינויים",
        Content = [[
### גרסה 1.8.7
- הוסר לחלוטין הניבוי החכם.
- נוסף כפתור בכרטיסיית 'שונות' לנטרול כל ההתראות.

### גרסה 1.8.6
- הניבוי החכם נוצר מבוסס מדרג: מותאם ליניארית מ-0 (פינג < 30) ל-0.2 (פינג > 80), עם כפל דינמי מדויק לכל פריים (לדוגמה, ב-50ms ~0.08, ב-51ms ~0.082).

### גרסה 1.8.5
- נוסף כפתור 'ניבוי חכם' שמחשב הובלה (Lead) על בסיס פינג ומהירות המטרה; מכבה את רשימת הניבוי הרגילה כשהוא מופעל.
- תוקן הניבוי החכם להשתמש ב-LocalPlayer:GetNetworkPing() והותאם זמן ההובלה לחישוב מדויק (בינוני ב-~55ms).

### גרסה 1.8.4
- שונתה המהירות המקסימלית של מעגל הקשת ל-3 לאפקט איטי יותר.

### גרסה 1.8.3
- הוסרו כל ההתראות הקשורות ליצירת/אתחול ESP לשחקנים ואירועי נעילת איימבוט.

### גרסה 1.8.2
- יושמו תיקונים קלים: נוספה תאימות R15/R6 ל-Skeleton ESP, סליידר למהירות קשת בכרטיסיית 'מעגל', ניקוי מטמון חומרי פלסטיק בעת כניסה/יציאה של שחקן, תיקון אתחול objectCache לטיפול תקין ב-UnloadAll.

### גרסה 1.8.1
- תוקנה שגיאת קריאה חוזרת ב-Skeleton ESP על ידי שיפור טיפול בשגיאות
- הודרו התראות שגיאה לא קריטיות עבור Skeleton ESP
- נוסף רישום שגיאות Skeleton ESP לקונסולה במקום התראות ממשק משתמש
- שופרה אימות הדמות והחלקים ב-Skeleton ESP למניעת שגיאות

### גרסה 1.8.0
- תוקנה אפשרות החלפת הנראות של Skeleton ESP לעדכון מיידי ללא צורך באיפוס
- הובטח ש-Skeleton ESP יופעל רק עבור שחקנים כאשר הוא מופעל
- שופרה לולאת הרינדור של Skeleton ESP לאכיפת נראות
- נוספו התראות דיבוג להפעלת Skeleton ESP ובעיות רינדור

### גרסה 1.7.9
- נוסף מחיצה "הגדרות תנועה" בכרטיסיית 'שחקן'
- שופרו כפתורי האיפוס של מהירות הליכה וכוח קפיצה לעדכון ערכים תקין
- ממיר Hitbox Expander למתג עם סליידר גודל ופונקציונליות יישום/איפוס תקינה
- תוקנה נראות קווי Skeleton ESP ויישום צבע
- תוקן Skeleton ESP שלא הציג קווים
- נוסף מחיצה "הגדרות נוספות" בכרטיסיית 'שחקן' עבור Fly, Noclip, Infinite Jump
- כפתור 'בטל טעינת סקריפט' הועבר לראש כרטיסיית 'שונות' עם מחיצה
- נוסף כפתור 'העתק קישור דיסקורד' בכרטיסיית 'בית'
- אומתה פונקציונליות בורר הצבעים של Skeleton ESP
- שופר הטיפול בשגיאות עבור Skeleton ESP

### גרסה 1.7.8
- שוחזרו מחיצות כרטיסיות ואלמנטים מאורגנים בממשק המשתמש
- תוקן בורר הצבעים של Skeleton ESP שלא הגיב
- תוקן Skeleton ESP שלא הציג קווים
- נוספו כפתורי 'אפס מהירות הליכה' ו'אפס כוח קפיצה' לכרטיסיית 'שחקן'
- אומתה פונקציונליות נעילת המטרה של איימבוט
- שופר הטיפול בשגיאות עבור ESP ובורר הצבעים

### גרסה 1.7.7
- תוקנה כרטיסיית 'שחקן' שלא הופיעה
- תוקנו הפקדים בכרטיסיית 'שונות' שלא הופיעו
- תוקנה כרטיסיית ESP (תיבה, שלד, שמות) שלא פעלה
- שופרה נעילת המטרה של איימבוט לאכיפת FOV
- נוספו התראות דיבוג לכשלים בכרטיסיות

### גרסה 1.7.6
- תוקנה נעילת המטרה של איימבוט לשמירת נעילה בתוך ה-FOV
- נוספה התראה לניקוי נעילה
- אוחד הסקריפט לבלוק יחיד
- אומתה פונקציונליות 'שונות', 'שחקן' ו-ESP

### גרסה 1.7.5
- נוסף מתג 'נעילת מטרה' לאיימבוט
- נוסף מתג 'שמות ESP'
- נוסף בורר צבעים נפרד ל-Skeleton ESP
- כרטיסיית 'שונות' הועברה לפקדים מלאים
- תוקנו פונקציונליות כרטיסיית 'שחקן' ו-ESP

### גרסה 1.7.4
- נוספו כפתורי 'מפעיל האבים'
- תוקנה נראות ה-Hitbox Expander

### גרסה 1.7.3
- נוספו הדפסי דיבוג ליצירת קו

### גרסה 1.7.2
- תוקנה תיבה אפורה בדמויות שחקנים
- תוקן Box ESP שלא הופיע
- אומת ניקוי Anti-Fling

### גרסה 1.7.1
- סודר מחדש יומן השינויים
- תוקנה שינוי גודל דינמי של Box ESP
- אומת ניקוי Anti-Fling

### גרסה 1.7.0
- יומן השינויים הוגדר כניתן לגלילה
- תוקן ניקוי Anti-Fling

### גרסה 1.6.9
- נוסף ניקוי Hitbox Expander

### גרסה 1.6.8
- תוקנו באגים ב-Fly וב-Anti-Fling

### גרסה 1.6.7
- עודכן Fly: מהירות 50-1000, נשמר לאחר מוות
- נוסף מתג Anti-Fling עם /antion, /antioff
- Bring All ו-Hitbox Expander הועברו לכרטיסיית 'שונות'

### גרסה 1.5.5
- גרסה ראשונית עם כרטיסיות בית, איימבוט, מעגל, ESP, שחקן, שונות
        ]]
    })

    -- ======= כרטיסיית איימבוט (לא לנייד) =======
    local aimConn = nil
    if not isMobile then
        local success, err = pcall(function()
            AimbotTab:CreateSection("הגדרות איימבוט")
            AimbotTab:CreateToggle({
                Name = "אפשר איימבוט",
                CurrentValue = getgenv().AimbotSettings.Enabled,
                Callback = function(v)
                    getgenv().AimbotSettings.Enabled = v
                    if not v then
                        getgenv().AimbotSettings.LockedTarget = nil
                    end
                end
            })
            AimbotTab:CreateToggle({
                Name = "איימבוט חכם",
                CurrentValue = getgenv().AimbotSettings.SmartAimbot,
                Callback = function(v) getgenv().AimbotSettings.SmartAimbot = v end
            })
            AimbotTab:CreateToggle({
                Name = "נעל מטרה",
                CurrentValue = getgenv().AimbotSettings.LockTarget,
                Callback = function(v)
                    getgenv().AimbotSettings.LockTarget = v
                    if not v then
                        getgenv().AimbotSettings.LockedTarget = nil
                    end
                end
            })
            AimbotTab:CreateToggle({
                Name = "בדיקת קבוצה",
                CurrentValue = getgenv().AimbotSettings.TeamCheck,
                Callback = function(v) getgenv().AimbotSettings.TeamCheck = v end
            })
            AimbotTab:CreateDropdown({
                Name = "ניבוי",
                Options = {"כבוי", "נמוך", "בינוני", "גבוה"},
                CurrentOption = {getgenv().AimbotSettings.Prediction},
                Callback = function(opt) getgenv().AimbotSettings.Prediction = opt[1] end
            })
            AimbotTab:CreateDropdown({
                Name = "החלקה",
                Options = {"כבוי", "נמוך", "בינוני", "גבוה"},
                CurrentOption = {getgenv().AimbotSettings.Smoothing},
                Callback = function(opt) getgenv().AimbotSettings.Smoothing = opt[1] end
            })
            AimbotTab:CreateDropdown({
                Name = "מצב הפעלה",
                Options = {"החזקה", "החלפה"},
                CurrentOption = {getgenv().AimbotSettings.Mode},
                Callback = function(opt) getgenv().AimbotSettings.Mode = opt[1] end
            })
            AimbotTab:CreateDropdown({
                Name = "חלק גוף למטרה",
                Options = {"ראש", "טורסו"},
                CurrentOption = {getgenv().AimbotSettings.TargetPart},
                Callback = function(opt) getgenv().AimbotSettings.TargetPart = opt[1] end
            })
        end)
        if not success then
            warn("יצירת כרטיסיית איימבוט נכשלה: " .. tostring(err))
            if not getgenv().MiscSettings.DisableNotifications then
                Rayfield:Notify({
                    Title = "שגיאת Valox Hub",
                    Content = "יצירת כרטיסיית איימבוט נכשלה: " .. tostring(err),
                    Duration = 5
                })
            end
        end

        local aimActive = false
        UserInputService.InputBegan:Connect(function(input, processed)
            if processed then return end
            if getgenv().AimbotSettings.Mode == "Hold" and input.UserInputType == Enum.UserInputType.MouseButton2 then
                aimActive = true
            elseif getgenv().AimbotSettings.Mode == "Toggle" and input.UserInputType == Enum.UserInputType.MouseButton2 then
                aimActive = not aimActive
            end
        end)
        UserInputService.InputEnded:Connect(function(input)
            if getgenv().AimbotSettings.Mode == "Hold" and input.UserInputType == Enum.UserInputType.MouseButton2 then
                aimActive = false
            end
        end)

        local function smoothingFactorFromSetting()
            local s = getgenv().AimbotSettings.Smoothing
            return (s == "Off" and 1) or (s == "Low" and 0.15) or (s == "Medium" and 0.08) or (s == "High" and 0.03) or 0.1
        end

        local function getClosest()
            local mousePos = UserInputService:GetMouseLocation()
            if getgenv().AimbotSettings.LockTarget and getgenv().AimbotSettings.LockedTarget then
                local target = getgenv().AimbotSettings.LockedTarget
                local char = target.Character
                local hum = char and char:FindFirstChildOfClass("Humanoid")
                local root = char and char:FindFirstChild("HumanoidRootPart")
                if hum and root and hum.Health > 0 then
                    if getgenv().AimbotSettings.TeamCheck and target.Team == LocalPlayer.Team then
                        getgenv().AimbotSettings.LockedTarget = nil
                    else
                        local screenPos, onScreen = Camera:WorldToViewportPoint(root.Position)
                        if onScreen and (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(mousePos.X, mousePos.Y)).Magnitude <= getgenv().CircleSettings.FOV then
                            return target
                        else
                            getgenv().AimbotSettings.LockedTarget = nil
                        end
                    end
                else
                    getgenv().AimbotSettings.LockedTarget = nil
                end
            end
            local closest, shortestDist = nil, math.huge
            for _, plr in pairs(Players:GetPlayers()) do
                if plr == LocalPlayer then continue end
                local char = plr.Character
                local hum = char and char:FindFirstChildOfClass("Humanoid")
                local root = char and char:FindFirstChild("HumanoidRootPart")
                if hum and root and hum.Health > 0 then
                    if getgenv().AimbotSettings.TeamCheck and plr.Team == LocalPlayer.Team then continue end
                    local screenPos, onScreen = Camera:WorldToViewportPoint(root.Position)
                    if not onScreen then continue end
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(mousePos.X, mousePos.Y)).Magnitude
                    if dist < shortestDist and dist <= getgenv().CircleSettings.FOV then
                        closest = plr
                        shortestDist = dist
                    end
                end
            end
            if closest and getgenv().AimbotSettings.LockTarget and not getgenv().AimbotSettings.LockedTarget then
                local char = closest.Character
                local root = char and char:FindFirstChild("HumanoidRootPart")
                if root then
                    local screenPos, onScreen = Camera:WorldToViewportPoint(root.Position)
                    if onScreen and (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(mousePos.X, mousePos.Y)).Magnitude <= getgenv().CircleSettings.FOV then
                        getgenv().AimbotSettings.LockedTarget = closest
                    end
                end
            end
            return closest
        end

        aimConn = RunService.RenderStepped:Connect(function()
            if not getgenv().AimbotSettings.Enabled then return end
            if getgenv().AimbotSettings.Mode == "Hold" and not aimActive then return end
            if getgenv().AimbotSettings.Mode == "Toggle" and not aimActive then return end
            local target = getClosest()
            if not target or not target.Character then return end
            local hum = target.Character:FindFirstChildOfClass("Humanoid")
            if not hum or hum.Health <= 0 then return end
            local finalPart = getAimPartFromName(target.Character, getgenv().AimbotSettings.TargetPart)
            if not finalPart then return end
            if getgenv().AimbotSettings.SmartAimbot then
                local origin = Camera.CFrame.Position
                local direction = (finalPart.Position - origin)
                local rayParams = RaycastParams.new()
                rayParams.FilterType = Enum.RaycastFilterType.Blacklist
                rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
                local result = workspace:Raycast(origin, direction, rayParams)
                if result and result.Instance and result.Instance:IsA("BasePart") and not result.Instance:IsDescendantOf(target.Character) then
                    local headPart = target.Character:FindFirstChild("Head")
                    if headPart and finalPart ~= headPart then
                        finalPart = headPart
                    end
                end
            end
            local targetPos = finalPart.Position
            local hrp = target.Character:FindFirstChild("HumanoidRootPart")
            if hrp and getgenv().AimbotSettings.Prediction ~= "Off" then
                local mult = (getgenv().AimbotSettings.Prediction == "Low" and 0.06)
                    or (getgenv().AimbotSettings.Prediction == "Medium" and 0.11)
                    or (getgenv().AimbotSettings.Prediction == "High" and 0.2)
                    or 0
                targetPos = targetPos + hrp.Velocity * mult
            end
            local camCF = Camera.CFrame
            local wanted = CFrame.new(camCF.Position, targetPos)
            Camera.CFrame = camCF:Lerp(wanted, smoothingFactorFromSetting())
        end)
        table.insert(getgenv().Connections, aimConn)
    end

    -- ======= כרטיסיית מעגל (לא לנייד) =======
    local mainCircle = nil
    local circleConn = nil
    if not isMobile then
        local success, err = pcall(function()
            CircleTab:CreateSection("הגדרות מעגל")
            CircleTab:CreateSlider({
                Name = "FOV (שדה ראייה)",
                Range = {50, 500},
                Increment = 10,
                CurrentValue = getgenv().CircleSettings.FOV,
                Callback = function(v) getgenv().CircleSettings.FOV = v end
            })
            CircleTab:CreateColorPicker({
                Name = "צבע מעגל",
                Color = getgenv().CircleSettings.Color,
                Callback = function(v)
                    local success, err = pcall(function()
                        getgenv().CircleSettings.Color = v
                    end)
                    if not success then
                        warn("בורר הצבעים של מעגל נכשל: " .. tostring(err))
                    end
                end
            })
            CircleTab:CreateToggle({
                Name = "מעגל קשת",
                CurrentValue = getgenv().CircleSettings.Rainbow,
                Callback = function(v) getgenv().CircleSettings.Rainbow = v end
            })
            CircleTab:CreateSlider({
                Name = "עובי",
                Range = {1, 10},
                Increment = 1,
                CurrentValue = getgenv().CircleSettings.Thickness,
                Callback = function(v) getgenv().CircleSettings.Thickness = v end
            })
            CircleTab:CreateSlider({
                Name = "מהירות קשת",
                Range = {1, 3},
                Increment = 1,
                CurrentValue = getgenv().CircleSettings.RainbowSpeed,
                Callback = function(v) getgenv().CircleSettings.RainbowSpeed = v end
            })
            CircleTab:CreateToggle({
                Name = "הצג מעגל",
                CurrentValue = getgenv().CircleSettings.Visible,
                Callback = function(v)
                    getgenv().CircleSettings.Visible = v
                    if mainCircle then pcall(function() mainCircle.Visible = v end) end
                end
            })
        end)
        if not success then
            warn("יצירת כרטיסיית מעגל נכשלה: " .. tostring(err))
            if not getgenv().MiscSettings.DisableNotifications then
                Rayfield:Notify({
                    Title = "שגיאת Valox Hub",
                    Content = "יצירת כרטיסיית מעגל נכשלה: " .. tostring(err),
                    Duration = 5
                })
            end
        end

        local function CreateMainCircle()
            DestroyAllCircles()
            local m = UserInputService:GetMouseLocation()
            local c = Drawing.new("Circle")
            c.NumSides = 100
            c.Filled = false
            c.Visible = getgenv().CircleSettings.Visible
            c.Thickness = getgenv().CircleSettings.Thickness
            c.Radius = getgenv().CircleSettings.FOV
            c.Position = Vector2.new(m.X, m.Y)
            c.Color = getgenv().CircleSettings.Color
            table.insert(getgenv().ActiveCircles, c)
            return c
        end

        mainCircle = CreateMainCircle()
        circleConn = RunService.RenderStepped:Connect(function()
            if not mainCircle then return end
            local m = UserInputService:GetMouseLocation()
            pcall(function()
                mainCircle.Position = Vector2.new(m.X, m.Y)
                mainCircle.Radius = getgenv().CircleSettings.FOV
                mainCircle.Thickness = getgenv().CircleSettings.Thickness
                mainCircle.Visible = getgenv().CircleSettings.Visible
                if getgenv().CircleSettings.Rainbow then
                    local time = tick() * getgenv().CircleSettings.RainbowSpeed
                    mai
